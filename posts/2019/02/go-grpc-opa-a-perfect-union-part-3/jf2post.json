{"author":{"name":"Yash Agarwal","type":"card","url":"https://yashagarwal.in/"},"content":{"html":"\u003cp\u003eI finished my last \u003ca href=\"/posts/2019/02/go-grpc-opa-a-perfect-union-part-2/\"\u003epost\u003c/a\u003e with the following issue -\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNow, here one problem arises, how to make sure that the search results will not return any book which the user is not\nauthorized to access. We will solve this problem using OPA in the next and last post of this series.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLet\u0026rsquo;s solve this issue now. We will use OPA\u0026rsquo;s declarative language, Rego, to implement policies which will decide on the\nbasis of some user-provided data, which all objects are to be returned to the user.\u003c/p\u003e\n\u003cp\u003eWe will also define a list of all the users who are part of this library. Here we are hardcoding this data, as I did\nnot want to waste my time in implementing a user registration service, but this functionality is not very important from\nour point of view. We will require only one field from this users data - the \u003ccode\u003euser_type\u003c/code\u003e field. This field will\ndetermine what the access level for the user is. We have already added the \u003ccode\u003eaccess_level\u003c/code\u003e field in the \u003ccode\u003eBook\u003c/code\u003e definition\nof our proto file.\u003c/p\u003e\n\u003cp\u003eWhen the user wants to search for a particular book, it will provide its \u003ccode\u003euser_type\u003c/code\u003e the ISBN of the book to our service. Our service\nwill take that ISBN and pass it to the OPA server. OPA server already has the \u003ccode\u003eBook\u003c/code\u003e data and the \u003ccode\u003eUser\u003c/code\u003e data. Now it has\nthe required ISBN to query the Book data. The Rego policy will query the Book data by ISBN. It will also\ncheck for the \u003ccode\u003eaccess_level\u003c/code\u003e condition. Moreover, after this operation, it will return the resultant set of books that satisfy both the requirements.\u003c/p\u003e\n\u003cp\u003eHere is the Rego policy -\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-ruby\" data-lang=\"ruby\"\u003e\u003cspan class=\"n\"\u003epackage\u003c/span\u003e \u003cspan class=\"n\"\u003elibrary\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebooks\u003c/span\u003e\n\u003cspan class=\"n\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eusers\u003c/span\u003e\n\u003cspan class=\"n\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003einput\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003esearch_books\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ebook\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebook\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisbn\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ebooks\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003eisbn\u003c/span\u003e\n  \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euser\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euser_type\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ebooks\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003eaccess_level\u003c/span\u003e\n  \u003cspan class=\"n\"\u003ebook\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebooks\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003elist_all_books\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ebooks\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e]]\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"n\"\u003einput\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euser\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003euser_type\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ebooks\u003c/span\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003eaccess_level\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe user data is \u003ca href=\"https://github.com/yashhere/go-library-service/blob/master/OPA/users.json\"\u003ehere\u003c/a\u003e and the book data is \u003ca href=\"https://github.com/yashhere/go-library-service/blob/master/add_books.sh\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eA sample \u003ccode\u003einput\u003c/code\u003e request is shown below -\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nt\"\u003e\u0026#34;input\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nt\"\u003e\u0026#34;book\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"nt\"\u003e\u0026#34;isbn\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;1128959038\u0026#34;\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n        \u003cspan class=\"nt\"\u003e\u0026#34;user\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"nt\"\u003e\u0026#34;user_type\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003einput\u003c/code\u003e is the data that the user is providing. In \u003ccode\u003esearch_books\u003c/code\u003e function, the input ISBN is matched with the ISBN\nof all books one by one. Then the resultant set of books is filtered by \u003ccode\u003euser_type\u003c/code\u003e and \u003ccode\u003eaccess_level\u003c/code\u003e (these\ntwo fields are essentially the same). In the last, the resultant set of books is assigned to the variable \u003ccode\u003ebook\u003c/code\u003e which\nwill be returned to the gRPC service.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003elist_all_books\u003c/code\u003e function is implemented similarly. The only difference is that we do not need to filter the books\nby ISBN. Filtering by \u003ccode\u003eaccess_level\u003c/code\u003e is enough.\u003c/p\u003e\n\u003cp\u003eNow our library service is completed. It is a very basic service. The intention was to show that the decision-making process can be offloaded to the OPA to reduce the complexity of the services. In this example, the advantages might not\nbe obvious, but in large production environments, where many services are running, it can make a significant\ndifference.\u003c/p\u003e\n\u003cp\u003eThe code for this series can be found on my \u003ca href=\"https://github.com/yashhere/go-library-service\"\u003eGithub\u003c/a\u003e account.\u003c/p\u003e\n\u003cp\u003eI hope you liked the article. Share your views and suggestions in the comments.\u003c/p\u003e\n\u003cp\u003eThanks for reading. Cheers :)\u003c/p\u003e\n","text":"I finished my last post with the following issue -\n Now, here one problem arises, how to make sure that the search results will not return any book which the user is not authorized to access. We will solve this problem using OPA in the next and last post of this series.\n Let\u0026rsquo;s solve this issue now. We will use OPA\u0026rsquo;s declarative language, Rego, to implement policies which will decide on the basis of some user-provided data, which all objects are to be returned to the user.\nWe will also define a list of all the users who are part of this library. Here we are hardcoding this data, as I did not want to waste my time in implementing a user registration service, but this functionality is not very important from our point of view. We will require only one field from this users data - the user_type field. This field will determine what the access level for the user is. We have already added the access_level field in the Book definition of our proto file.\nWhen the user wants to search for a particular book, it will provide its user_type the ISBN of the book to our service. Our service will take that ISBN and pass it to the OPA server. OPA server already has the Book data and the User data. Now it has the required ISBN to query the Book data. The Rego policy will query the Book data by ISBN. It will also check for the access_level condition. Moreover, after this operation, it will return the resultant set of books that satisfy both the requirements.\nHere is the Rego policy -\npackage library import data.books import data.users import input search_books[book] { input.book.isbn == books[i].isbn input.user.user_type \u0026gt;= books[i].access_level book = books[i] } list_all_books[books[i]] { input.user.user_type \u0026gt;= books[i].access_level } The user data is here and the book data is here.\nA sample input request is shown below -\n{ \u0026#34;input\u0026#34;: { \u0026#34;book\u0026#34;: { \u0026#34;isbn\u0026#34;: \u0026#34;1128959038\u0026#34; }, \u0026#34;user\u0026#34;: { \u0026#34;user_type\u0026#34;: 3 } } } The input is the data that the user is providing. In search_books function, the input ISBN is matched with the ISBN of all books one by one. Then the resultant set of books is filtered by user_type and access_level (these two fields are essentially the same). In the last, the resultant set of books is assigned to the variable book which will be returned to the gRPC service.\nThe list_all_books function is implemented similarly. The only difference is that we do not need to filter the books by ISBN. Filtering by access_level is enough.\nNow our library service is completed. It is a very basic service. The intention was to show that the decision-making process can be offloaded to the OPA to reduce the complexity of the services. In this example, the advantages might not be obvious, but in large production environments, where many services are running, it can make a significant difference.\nThe code for this series can be found on my Github account.\nI hope you liked the article. Share your views and suggestions in the comments.\nThanks for reading. Cheers :)\n"},"name":"Go + gRPC + OPA - A Perfect Union - Part 3","published":"2019-02-18T06:47:15+05:30","summary":"I finished my last post with the following issue -\n Now, here one problem arises, how to make sure that the search results will not return any book which the user is not authorized to access. We will solve this problem using OPA in the next and last post of this series.\n Let\u0026rsquo;s solve this issue now. We will use OPA\u0026rsquo;s declarative language, Rego, to implement policies which will decide on the basis of some user-provided data, which all objects are to be returned to the user.","type":"entry","url":"https://yashagarwal.in/posts/2019/02/go-grpc-opa-a-perfect-union-part-3/"}