{"author":{"name":"Yash Agarwal","type":"card","url":"https://yashagarwal.in/"},"content":{"html":"\u003cp\u003e\u003cstrong\u003eTL;DR\u003c/strong\u003e \u0026ndash; In a series of blog posts, I will be implementing a simple library application supporting both gRPC and REST interfaces using Go, gRPC, and\nOPA. My approach might not be the most optimal one, but I am learning these technologies currently. Please give your\nvaluable suggestions and be kind :)\u003c/p\u003e\n\u003cp\u003eI have been learning the basics of microservices and Golang lately. On the work front, I got a chance to work on Go, gRPC, and Open\nPolicy Agent as my first professional project. In this post, I will be demonstrating what I learned in the last few months.\nWe will be implementing a simple gRPC based library service, which will be able to serve\nrequests using both gRPC and REST calls. It will also incorporate the Open Policy Agent (OPA) to provide the authorization\nto users. Let\u0026rsquo;s begin with a quick introduction to gRPC and OPA.\u003c/p\u003e\n\u003ch2 id=\"grpc\"\u003egRPC\u003c/h2\u003e\n\u003cp\u003egRPC is Google\u0026rsquo;s implementation for Remote Procedure Calls(RPC). RPC is mainly used in building scalable distributed systems. While REST has a limited set of verbs, RPC can define any function calls, including synchronous and asynchronous calls.\u003c/p\u003e\n\u003cp\u003eIn gRPC, the client can make procedure calls as if the requests are made to some local function. However, the underlying client\nstub (auto-generated) will send the call to the server. The server will have a similar server stub, which will be able to\nhandle the requests coming from the client. The server will send the response to the client using similar mechanisms\nover the network. All the communication is serialized to binary format, so it is ideal for distributed systems as binary format\ntends to be on the faster side for large amounts of data.\u003c/p\u003e\n\u003cp\u003eFor more info about gRPC, visit the official \u003ca href=\"https://grpc.io/\"\u003ewebsite\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"open-policy-agent-opa\"\u003eOpen Policy Agent (OPA)\u003c/h2\u003e\n\u003cp\u003eOPA gives us the ability to define a fine-grained policy control mechanism. However, I think the most critical benefit of\nusing OPA is that it gives you the ability to decouple your services and the definition of policies from the enforcement\nof it.\u003c/p\u003e\n\u003cp\u003eThere are mainly two parts of OPA -\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA JSON document store where you can define anything from your users, access roles,\npermission levels, etc.\u003c/li\u003e\n\u003cli\u003eA policy is written in a declarative language. This policy gives you new derivative data from the original JSON document store evaluated by the policy. The declarative language is called Rego, and these policies are also documents that generate results according to the defined policy. The users query these results.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis info will be sufficient for our use case. More info about it can be found at the official\n\u003ca href=\"https://www.openpolicyagent.org/\"\u003ewebsite\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"the-skeleton-of-our-application\"\u003eThe skeleton of our Application\u003c/h2\u003e\n\u003cp\u003eWe will be building a command-line library application. This application will support adding, deleting, searching, issuing, and returning of\nbooks. There are three types of users \u0026ndash; student, faculties, and staff. Not all users have a similar kind of access level. There are some books which are only reserved for students, and some are exclusively reserved for faculties and so on.\u003c/p\u003e\n\u003cp\u003eI think emulating the \u003ca href=\"https://harrypotter.fandom.com/wiki/Hogwarts_Library\"\u003elibrary\u003c/a\u003e at Hogwarts will be a good idea here. Students and ordinary people were not allowed inside\nthe restricted section of the library. We will emulate that restricted section using the authorization mechanisms\nprovided by OPA.\u003c/p\u003e\n\u003cp\u003eThe gRPC protocol will handle the communications part in our app, but not everyone in Hogwarts is using gRPC. Wizards\nare still in love with REST (not a bad thing, though), so we will provide them alike the REST interface to interact\nwith our service. We do not want to face the wrath of the wizards, after all.\u003c/p\u003e\n\u003cp\u003eOPA can either be used as a standalone application or be embedded in the Go service as well. Both approaches have\ntheir pros and cons. I have decided to use OPA as an independent service, as it will be more comfortable that way for us to push\nauthorization data and policies to it if such a need arises in the future.\u003c/p\u003e\n\u003cp\u003eOne more issue remains - where to store the added books. Shall we persist them? In practical scenarios, persistence is\nalways a good idea, but here I do not want to complicate things too much. We could use any Object storage servers (e.g., Minio) to\nstore the JSON data generated from our gRPC methods, but that will unnecessarily add complexity to our simple scenario.\nWizards do not like complicate stuff, you know!\u003c/p\u003e\n\u003cp\u003eIn the next posts, we will define our gRPC proto file and build the Go service around it. Then we will add a REST\ninterface to our service for simple CRUD operations in our application. Then we will add OPA authorization to restrict\nour users from adding and viewing books which they are not supposed to access.\u003c/p\u003e\n\u003cp\u003eThank you for reading. Cheers ðŸ˜Š\u003c/p\u003e\n","text":"TL;DR \u0026ndash; In a series of blog posts, I will be implementing a simple library application supporting both gRPC and REST interfaces using Go, gRPC, and OPA. My approach might not be the most optimal one, but I am learning these technologies currently. Please give your valuable suggestions and be kind :)\nI have been learning the basics of microservices and Golang lately. On the work front, I got a chance to work on Go, gRPC, and Open Policy Agent as my first professional project. In this post, I will be demonstrating what I learned in the last few months. We will be implementing a simple gRPC based library service, which will be able to serve requests using both gRPC and REST calls. It will also incorporate the Open Policy Agent (OPA) to provide the authorization to users. Let\u0026rsquo;s begin with a quick introduction to gRPC and OPA.\ngRPC gRPC is Google\u0026rsquo;s implementation for Remote Procedure Calls(RPC). RPC is mainly used in building scalable distributed systems. While REST has a limited set of verbs, RPC can define any function calls, including synchronous and asynchronous calls.\nIn gRPC, the client can make procedure calls as if the requests are made to some local function. However, the underlying client stub (auto-generated) will send the call to the server. The server will have a similar server stub, which will be able to handle the requests coming from the client. The server will send the response to the client using similar mechanisms over the network. All the communication is serialized to binary format, so it is ideal for distributed systems as binary format tends to be on the faster side for large amounts of data.\nFor more info about gRPC, visit the official website.\nOpen Policy Agent (OPA) OPA gives us the ability to define a fine-grained policy control mechanism. However, I think the most critical benefit of using OPA is that it gives you the ability to decouple your services and the definition of policies from the enforcement of it.\nThere are mainly two parts of OPA -\n A JSON document store where you can define anything from your users, access roles, permission levels, etc. A policy is written in a declarative language. This policy gives you new derivative data from the original JSON document store evaluated by the policy. The declarative language is called Rego, and these policies are also documents that generate results according to the defined policy. The users query these results.  This info will be sufficient for our use case. More info about it can be found at the official website.\nThe skeleton of our Application We will be building a command-line library application. This application will support adding, deleting, searching, issuing, and returning of books. There are three types of users \u0026ndash; student, faculties, and staff. Not all users have a similar kind of access level. There are some books which are only reserved for students, and some are exclusively reserved for faculties and so on.\nI think emulating the library at Hogwarts will be a good idea here. Students and ordinary people were not allowed inside the restricted section of the library. We will emulate that restricted section using the authorization mechanisms provided by OPA.\nThe gRPC protocol will handle the communications part in our app, but not everyone in Hogwarts is using gRPC. Wizards are still in love with REST (not a bad thing, though), so we will provide them alike the REST interface to interact with our service. We do not want to face the wrath of the wizards, after all.\nOPA can either be used as a standalone application or be embedded in the Go service as well. Both approaches have their pros and cons. I have decided to use OPA as an independent service, as it will be more comfortable that way for us to push authorization data and policies to it if such a need arises in the future.\nOne more issue remains - where to store the added books. Shall we persist them? In practical scenarios, persistence is always a good idea, but here I do not want to complicate things too much. We could use any Object storage servers (e.g., Minio) to store the JSON data generated from our gRPC methods, but that will unnecessarily add complexity to our simple scenario. Wizards do not like complicate stuff, you know!\nIn the next posts, we will define our gRPC proto file and build the Go service around it. Then we will add a REST interface to our service for simple CRUD operations in our application. Then we will add OPA authorization to restrict our users from adding and viewing books which they are not supposed to access.\nThank you for reading. Cheers ðŸ˜Š\n"},"name":"Go + gRPC + OPA - A Perfect Union - Part 1","published":"2019-02-10T14:29:08+05:30","summary":"TL;DR \u0026ndash; In a series of blog posts, I will be implementing a simple library application supporting both gRPC and REST interfaces using Go, gRPC, and OPA. My approach might not be the most optimal one, but I am learning these technologies currently. Please give your valuable suggestions and be kind :)\nI have been learning the basics of microservices and Golang lately. On the work front, I got a chance to work on Go, gRPC, and Open Policy Agent as my first professional project.","type":"entry","url":"https://yashagarwal.in/posts/2019/02/go-grpc-opa-a-perfect-union-part-1/"}